name: CI/CD prod

on:
  workflow_dispatch:
permissions: {}
concurrency: prod

jobs:
  build-push-prod:
    name: Build & Push New Image
    runs-on: ubuntu-latest
    permissions:
      id-token: write # This is required for requesting the JWT
      contents: write # This is required for actions/checkout
    environment: prod
    outputs:
      new_tag: ${{ steps.set-version-tag-output.outputs.new_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Bump version and push tag
        uses: anothrNick/github-tag-action@1.75.0
        id: bump-id
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          WITH_V: true

      - name: Set Version tag output
        id: set-version-tag-output
        run: echo "new_tag=${{ steps.bump-id.outputs.new_tag }}" >> $GITHUB_OUTPUT

      - name: Build
        env:
          NEW_TAG_V: ${{ steps.set-version-tag-output.outputs.new_tag }}
        shell: bash
        run: |
          docker build . \
            --build-arg BUILD_NUMBER=$NEW_TAG_V \
            --build-arg GIT_REF=${{ github.sha }} \
            --build-arg GIT_BRANCH=${{ github.ref_name }} \
            -t working_image:$NEW_TAG_V

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.PROD_ECR_ROLE_TO_ASSUME }}
          aws-region: ${{ vars.PROD_ECR_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ vars.PROD_ECR_REPOSITORY }}
          NEW_TAG_V: ${{ steps.set-version-tag-output.outputs.new_tag }}
        shell: bash
        run: |
          docker tag working_image:$NEW_TAG_V $ECR_REGISTRY/$ECR_REPOSITORY:$NEW_TAG_V
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$NEW_TAG_V

  deploy-prod:
    needs: build-push-prod
    name: Deploy Helm Chart into Cloud Platform
    runs-on: ubuntu-latest
    permissions:
      contents: write # This is required for actions/checkout
      id-token: write # This is required for requesting the JWT
    environment: prod
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Authenticate to the cluster
        env:
          KUBE_NAMESPACE: ${{ secrets.KUBE_NAMESPACE }}
          KUBE_CLUSTER: ${{ secrets.KUBE_CLUSTER }}
        run: |
          echo "${{ secrets.KUBE_CERT }}" > ca.crt
          kubectl config set-cluster ${KUBE_CLUSTER} --certificate-authority=./ca.crt --server=https://${KUBE_CLUSTER}
          kubectl config set-credentials deploy-user --token=${{ secrets.KUBE_TOKEN }}
          kubectl config set-context ${KUBE_CLUSTER} --cluster=${KUBE_CLUSTER} --user=deploy-user --namespace=${{ secrets.KUBE_NAMESPACE }}
          kubectl config use-context ${KUBE_CLUSTER}

      - name: Clone Helm chart repo
        run: |
          git clone https://github.com/ministryofjustice/track-my-case-cloud-platform.git
          git  -C track-my-case-cloud-platform checkout main

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.PROD_ECR_ROLE_TO_ASSUME }}
          aws-region: ${{ vars.PROD_ECR_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Upgrade the Helm chart
        env:
          APP_ROLE_ARN: ${{ secrets.APP_ROLE_ARN }}
          AUTHENTICATION_REQUIRED: ${{ vars.AUTHENTICATION_REQUIRED }}
          ECR_REPO_WEBAPP: ${{ steps.login-ecr.outputs.registry }}/${{ vars.PROD_ECR_REPOSITORY }}
          IP_RANGES: ${{ secrets.IP_RANGES }}
          KUBE_NAMESPACE: ${{ secrets.KUBE_NAMESPACE }}
          NEW_TAG_V: ${{ needs.build-push-prod.outputs.new_tag }}
          RELEASE_NAME: ${{ github.event.repository.name }}-prod
          SECRETS_CONTEXT:  ${{ toJson(secrets) }}
          VARS_CONTEXT:  ${{ toJson(vars) }}
        run: |
          process_ip_range=$(echo $IP_RANGES | sed "s/,/\\\,/g")

          combined_json=$(jq -n \
              --argjson secrets_json "$SECRETS_CONTEXT" \
              --argjson vars_json "$VARS_CONTEXT" \
              '$secrets_json + $vars_json')

          custom_variables_array=()
          for row in $(echo "$combined_json" | jq -r 'to_entries[] | @base64'); do
            key=$(echo "$row" | base64 --decode | jq -r '.key')
            value=$(echo "$row" | base64 --decode | jq -r '.value')

            if [[ $key == TMC_* ]]; then
              custom_key="Secrets.WebApp.Parameters.${key}"

              # Trim spaces from both ends
              safe_value="$(echo "$value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"

              # Compare raw vs. trimmed
              if [[ "$value" != "$safe_value" ]]; then
                echo "ERROR: Value for key '${custom_key}' has leading/trailing whitespace"
                exit 1
              fi

              # Wrap in quotes to keep value intact for Helm/YAML
              custom_variables_array+=("--set-string" "${custom_key}=${safe_value}")
             fi
          done

          # Debug
          echo "=== DEBUG: custom_variables_array ==="
          printf '%s\n' "${custom_variables_array[@]}"

          if helm status "$RELEASE_NAME" -n "$KUBE_NAMESPACE" >/dev/null 2>&1; then
            helm status  "$RELEASE_NAME" -n "$KUBE_NAMESPACE" || true
            helm history "$RELEASE_NAME" -n "$KUBE_NAMESPACE" || true

            # safe to inspect history / rollback / clear pending
            state=$(helm status "$RELEASE_NAME" -n "$KUBE_NAMESPACE" -o json 2>/dev/null | jq -r '.info.status | select(.!=null)')
            # Auto-clear pending-* for the current release
            if [[ "$state" == pending-* ]]; then
              latest=$(helm history "$RELEASE_NAME" -n "$KUBE_NAMESPACE" -o json | jq '.[-1].revision')
              echo "Helm release is $state at revision $latest — clearing it"
              # Try rollback to previous deployed if exists
              prev=$(helm history "$RELEASE_NAME" -n "$KUBE_NAMESPACE" -o json | jq '[.[] | select(.status=="deployed")][-1].revision')
              if [[ -n "$prev" ]]; then
                echo "Rolling back to deployed revision $prev..."
                helm rollback "$RELEASE_NAME" "$prev" -n "$KUBE_NAMESPACE" || true
              else
                echo "No deployed revision to roll back to (first install or all failed)."
              fi
            fi
          else
           echo "Release '$RELEASE_NAME' not found in namespace '$KUBE_NAMESPACE' — first install. Skipping history/rollback."
          fi

          echo "=== DEBUG: Helm command ==="
          set -x

          helm upgrade --install --dry-run --debug --namespace $KUBE_NAMESPACE $RELEASE_NAME ./track-my-case-cloud-platform/charts/webapp-cp \
          --set Namespace=$KUBE_NAMESPACE \
          --set WebApp.Image.Repository=$ECR_REPO_WEBAPP \
          --set WebApp.Image.Tag=$NEW_TAG_V \
          --set WebApp.Name=$KUBE_NAMESPACE \
          --set Ingress.ModSec.Enabled=true \
          --set securityContext.allowPrivilegeEscalation=false \
          --set securityContext.capabilities.drop=["ALL"] \
          --set securityContext.runAsNonRoot=true \
          --set securityContext.seccompProfile.type="RuntimeDefault" \
          --set Networkpolicy.Ingress="track-my-case-prod" \
          "${custom_variables_array[@]}"
          # > rendered.yaml

          # echo "=== DEBUG: webapp container only ==="
          # sed -n '/containers:/,/imagePullPolicy:/p' rendered.yaml \
          # | sed -n '/name: webapp/,$p' \
          # | sed -n '1,/^- name:/p'

          echo "=== Chart values: WebApp section ==="
          helm show values mojanalytics/webapp-cp | sed -n '/^WebApp:/,/^[A-Za-z]/p'

          helm upgrade --install --atomic --wait --timeout 10m0s --namespace $KUBE_NAMESPACE $RELEASE_NAME ./track-my-case-cloud-platform/charts/webapp-cp \
          --set Namespace=$KUBE_NAMESPACE \
          --set WebApp.Image.Repository=$ECR_REPO_WEBAPP \
          --set WebApp.Image.Tag=$NEW_TAG_V \
          --set WebApp.Name=$KUBE_NAMESPACE \
          --set Ingress.ModSec.Enabled=true \
          --set securityContext.allowPrivilegeEscalation=false \
          --set securityContext.capabilities.drop=["ALL"] \
          --set securityContext.runAsNonRoot=true \
          --set securityContext.seccompProfile.type="RuntimeDefault" \
          --set Networkpolicy.Ingress="track-my-case-prod" \
          "${custom_variables_array[@]}"

          echo "Labeling the service"
          kubectl label service --overwrite=true $KUBE_NAMESPACE app=$KUBE_NAMESPACE

      - name: Extract deployed service values for monitoring
        id: extract-values
        env:
          RELEASE_NAME: ${{ github.event.repository.name }}-prod
          KUBE_NAMESPACE: ${{ secrets.KUBE_NAMESPACE }}
        run: |
          echo "Extracting deployed Helm values..."

          SERVICE_NAME=$(helm get values "$RELEASE_NAME" -n "$KUBE_NAMESPACE" -o json | jq -r '.WebApp.Name')

          echo "ServiceName=$SERVICE_NAME"

          # Export them to the next step
          echo "service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT

      - name: Deploy Monitoring Helm chart
        env:
          KUBE_NAMESPACE: ${{ secrets.KUBE_NAMESPACE }}
        run: |
          helm upgrade --install monitoring-helmcharts ./monitoring-helmcharts \
            --namespace $KUBE_NAMESPACE \
            --set serviceName=${{ steps.extract-values.outputs.service_name }} \
            --set namespace=$KUBE_NAMESPACE \
            --set monitoring.interval="15s"
